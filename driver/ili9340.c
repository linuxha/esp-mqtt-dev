/*
 * ili9340.c
 *
 *  Created on: 14 Sep 2016
 *      Author: Peter
 */


// ************************* a spot of experimenting
// This should work perfectly - but it does not work at all. Logic analyser says yes
// display board says no.
//
// In this SPI, GPIO12 is MISO (din), GPIO13 is MOSI (dout), GPIO14 is clock
// GPIO15 is CS/SS and I've used GPIO16 as the D/C line. GPIO12 not actually used.

#include <ctype.h>

#include "espmissingincludes.h"
#include "aidan_and_petes.h"
#include "easygpio/include/easygpio/easygpio.h"
#include <math.h>
#include <c_types.h>
#include "include/driver/spi.h"

#define _BV(bit) (1 << (bit))

// ncherry@linuxha.com
// more of this silliness
extern void os_delay_us(uint32_t t);
extern void i2c_general(uint8 device_addr, uint8* data, uint16_t slength, uint16_t rlength);

extern uint8 read_rom_uint8(const uint8* addr);
extern uint16 read_rom_uint16(const uint16* addr);

/*
void IFA ili9340_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);
void IFA ili9340_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);
void IFA ili9340_drawRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color,uint16_t backColor);
void IFA ili9340_fillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
void IFA ili9340_setBackColor(uint16_t col);
void IFA ili9340_setFrontColor(uint16_t col);
void IFA ili9340_drawChar(uint16_t x, uint16_t y, uint8_t ch);
void IFA ili9340_drawBigChar(uint16_t x, uint16_t y, uint8_t ch);
*/

void IFA _wr_command(uint8_t c) ;
void IFA _wr_command16(uint16_t c) ;
void IFA _wr_data(uint8_t c) ;
void IFA _wr_data16(uint16_t c);
void _delay_ms(uint32_t dl);
void IFA ili9340_init(void) ;
void IFA ili9340_pushColor(uint16_t color) ;
void IFA ili9340_setScrollStart(uint16_t start);
void IFA ili9340_setScrollMargins(uint16_t top, uint16_t bottom) ;
void IFA ili9340_setAddrWindow(int16_t x0, int16_t y0, int16_t x1, int16_t y1) ;
void IFA ili9340_drawPixel(int16_t x, int16_t y, uint16_t color) ;
void IFA ili9340_drawLine(int16_t x0, int16_t y0,int16_t x1, int16_t y1,uint16_t color) ;
void IFA ili9340_drawRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color,uint16_t backColor) ;
void IFA ili9340_fillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) ;
void IFA ili9340_setBackColor(uint16_t col);
void IFA ili9340_setFrontColor(uint16_t col);
void IFA ili9340_drawChar(uint16_t x, uint16_t y, uint8_t ch);
void IFA ili9340_drawBigChar(uint16_t x, uint16_t y, uint8_t ch);
void IFA ili9340_drawBigString(uint16_t x, uint16_t y, const char *text);
void IFA ili9340_drawString(uint16_t x, uint16_t y, const char *text);
void IFA ili9340_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) ;
void IFA ili9340_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) ;
void IFA ili9340_setRotation(uint8_t m) ;
void IFA _vt100_reset(void);
void IFA _vt100_resetScroll(void);
void IFA _vt100_clearLines(uint16_t start_line, uint16_t end_line);
void IFA _vt100_scroll(int16_t lines);
void IFA _vt100_move(int16_t right_left, int16_t bottom_top);
void IFA _vt100_drawCursor();
void IFA _vt100_putc(uint8_t ch);
void IFA vt100_puts(const char *str);
void IFA vt100_putc(uint8_t c);

// Experiment - 16x16 font... left and right lsb to the right - start top of char and go down

static const uint8_t arial_bold[3040] ={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // <space>
0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,  // !
0x00,0x00,0x00,0x00,0x06,0x60,0x06,0x60,0x06,0x60,0x06,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // "
0x00,0x00,0x00,0x00,0x03,0x60,0x03,0x60,0x06,0xC0,0x3F,0xF0,0x3F,0xF0,0x06,0xC0,0x0D,0x80,0x3F,0xF0,0x3F,0xF0,0x0D,0x80,0x1B,0x00,0x1B,0x00,0x00,0x00,0x00,0x00,  // #
0x00,0x00,0x01,0x00,0x03,0x80,0x07,0xC0,0x0D,0x60,0x0D,0x00,0x0F,0x00,0x07,0x80,0x03,0xC0,0x01,0xE0,0x0D,0x60,0x0D,0x60,0x07,0xC0,0x03,0x80,0x01,0x00,0x00,0x00,  // $
0x00,0x00,0x00,0x00,0x3C,0x18,0x66,0x30,0x66,0x30,0x66,0x60,0x66,0xC0,0x3C,0xC0,0x01,0x9E,0x01,0xB3,0x03,0x33,0x03,0x33,0x06,0x33,0x0C,0x1E,0x00,0x00,0x00,0x00,  // %
0x00,0x00,0x00,0x00,0x07,0xC0,0x0F,0xE0,0x0C,0x60,0x0C,0x60,0x07,0xC0,0x07,0x80,0x0D,0x90,0x19,0xD8,0x18,0xF0,0x18,0x78,0x0F,0xFC,0x07,0x88,0x00,0x00,0x00,0x00,  // &
0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // '
0x00,0x00,0x01,0x80,0x03,0x00,0x03,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x03,0x00,0x03,0x00,0x01,0x80,0x00,0x00,0x00,0x00,  // (
0x00,0x00,0x06,0x00,0x03,0x00,0x03,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x03,0x00,0x03,0x00,0x06,0x00,0x00,0x00,0x00,0x00,  // )
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x03,0x80,0x33,0x98,0x3F,0xF8,0x07,0xC0,0x07,0xC0,0x0E,0xE0,0x1C,0x70,0x04,0x40,0x00,0x00,0x00,0x00,0x00,0x00,  // *
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x07,0xF8,0x07,0xF8,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // +
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x01,0x00,0x01,0x00,0x02,0x00,0x00,0x00,  // ,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // -
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // .
0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x60,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,  // /

0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // 0
0x00,0x00,0x00,0x00,0x01,0x80,0x03,0x80,0x07,0x80,0x0D,0x80,0x09,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,  // 1
0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x30,0x0C,0x30,0x00,0x30,0x00,0x60,0x00,0xE0,0x01,0xC0,0x03,0x80,0x06,0x00,0x0F,0xF0,0x0F,0xF0,0x00,0x00,0x00,0x00,  // 2
0x00,0x00,0x00,0x00,0x03,0xE0,0x07,0xF0,0x0E,0x30,0x00,0x30,0x01,0xE0,0x01,0xE0,0x00,0x70,0x00,0x30,0x0C,0x30,0x0E,0x70,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // 3
0x00,0x00,0x00,0x00,0x00,0x60,0x00,0xE0,0x00,0xE0,0x01,0xE0,0x03,0x60,0x03,0x60,0x06,0x60,0x0C,0x60,0x0F,0xF0,0x0F,0xF0,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,  // 4
0x00,0x00,0x00,0x00,0x07,0xE0,0x07,0xE0,0x06,0x00,0x0C,0x00,0x0F,0xC0,0x0F,0xE0,0x0C,0x70,0x00,0x30,0x0C,0x30,0x0E,0x70,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // 5
0x00,0x00,0x00,0x00,0x03,0xE0,0x07,0xF0,0x06,0x30,0x0C,0x00,0x0D,0xC0,0x0F,0xE0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x06,0x30,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // 6
0x00,0x00,0x00,0x00,0x0F,0xF0,0x0F,0xF0,0x00,0x60,0x00,0xC0,0x00,0xC0,0x01,0x80,0x01,0x80,0x01,0x80,0x03,0x80,0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,  // 7
0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x07,0xE0,0x07,0xE0,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // 8
0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0C,0x60,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x07,0xF0,0x03,0xB0,0x00,0x30,0x0C,0x60,0x0F,0xE0,0x07,0xC0,0x00,0x00,0x00,0x00,  // 9
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // :
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x80,0x00,0x80,0x01,0x00,0x00,0x00,  // ;
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0xE0,0x03,0xC0,0x0F,0x00,0x1C,0x00,0x0F,0x00,0x03,0xC0,0x00,0xE0,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,  // <
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xF0,0x1F,0xF0,0x00,0x00,0x00,0x00,0x1F,0xF0,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // =
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x0E,0x00,0x07,0x80,0x01,0xE0,0x00,0x70,0x01,0xE0,0x07,0x80,0x0E,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // >
0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x30,0x0C,0x30,0x00,0x70,0x00,0xE0,0x01,0xC0,0x01,0x80,0x01,0x80,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,  // ?

0x00,0x00,0x07,0xC0,0x0C,0x30,0x13,0x78,0x17,0xE8,0x2C,0xC8,0x2C,0xC8,0x2C,0xC8,0x2F,0xD0,0x26,0xE0,0x10,0x08,0x08,0x10,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,  // @
0x00,0x00,0x00,0x00,0x03,0x80,0x03,0x80,0x06,0xC0,0x06,0xC0,0x06,0xC0,0x0C,0x60,0x0C,0x60,0x0F,0xE0,0x1F,0xF0,0x18,0x30,0x18,0x30,0x30,0x18,0x00,0x00,0x00,0x00,  // A
0x00,0x00,0x00,0x00,0x1F,0xE0,0x1F,0xF0,0x18,0x30,0x18,0x30,0x18,0x30,0x1F,0xE0,0x1F,0xF0,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0xF0,0x1F,0xE0,0x00,0x00,0x00,0x00,  // B
0x00,0x00,0x00,0x00,0x03,0xE0,0x0F,0xF0,0x0C,0x38,0x1C,0x10,0x18,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x1C,0x10,0x0C,0x38,0x0F,0xF0,0x03,0xE0,0x00,0x00,0x00,0x00,  // C
0x00,0x00,0x00,0x00,0x1F,0xC0,0x1F,0xF0,0x18,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x30,0x1F,0xF0,0x1F,0xC0,0x00,0x00,0x00,0x00,  // D
0x00,0x00,0x00,0x00,0x0F,0xF8,0x0F,0xF8,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0F,0xF8,0x0F,0xF8,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0F,0xF8,0x0F,0xF8,0x00,0x00,0x00,0x00,  // E
0x00,0x00,0x00,0x00,0x0F,0xF0,0x0F,0xF0,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0F,0xE0,0x0F,0xE0,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,  // F
0x00,0x00,0x00,0x00,0x07,0xE0,0x1F,0xF0,0x18,0x38,0x38,0x10,0x30,0x00,0x30,0x00,0x30,0xF8,0x30,0xF8,0x38,0x18,0x18,0x38,0x1F,0xF8,0x07,0xE0,0x00,0x00,0x00,0x00,  // G
0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0xF8,0x1F,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,  // H
0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,  // I
0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x0C,0x30,0x0E,0x70,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,  // J
0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x18,0x60,0x18,0xC0,0x19,0x80,0x1B,0xC0,0x1E,0xC0,0x1C,0x60,0x18,0x70,0x18,0x30,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,  // K
0x00,0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0F,0xF0,0x0F,0xF0,0x00,0x00,0x00,0x00,  // L
0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x3C,0x78,0x3C,0x78,0x34,0x58,0x36,0xD8,0x36,0xD8,0x36,0xD8,0x33,0x98,0x33,0x98,0x33,0x98,0x31,0x18,0x00,0x00,0x00,0x00,  // M
0x00,0x00,0x00,0x00,0x18,0x18,0x1C,0x18,0x1E,0x18,0x1E,0x18,0x1B,0x18,0x19,0x98,0x19,0x98,0x18,0xD8,0x18,0x78,0x18,0x78,0x18,0x38,0x18,0x18,0x00,0x00,0x00,0x00,  // N
0x00,0x00,0x00,0x00,0x07,0xC0,0x1F,0xF0,0x18,0x30,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x18,0x18,0x30,0x1F,0xF0,0x07,0xC0,0x00,0x00,0x00,0x00,  // O

0x00,0x00,0x00,0x00,0x0F,0xE0,0x0F,0xF0,0x0C,0x38,0x0C,0x18,0x0C,0x38,0x0F,0xF0,0x0F,0xE0,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,  // P
0x00,0x00,0x00,0x00,0x07,0xC0,0x1F,0xF0,0x18,0x30,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x18,0x31,0xB8,0x18,0xF0,0x1F,0xF0,0x07,0xB0,0x00,0x18,0x00,0x00,  // Q
0x00,0x00,0x00,0x00,0x1F,0xE0,0x1F,0xF0,0x18,0x38,0x18,0x18,0x18,0x38,0x1F,0xF0,0x1F,0xC0,0x18,0xE0,0x18,0x70,0x18,0x30,0x18,0x38,0x18,0x1C,0x00,0x00,0x00,0x00,  // R
0x00,0x00,0x00,0x00,0x03,0xE0,0x07,0xF0,0x0E,0x38,0x0C,0x18,0x0F,0x00,0x07,0xE0,0x01,0xF0,0x00,0x38,0x0C,0x18,0x0E,0x38,0x07,0xF0,0x03,0xE0,0x00,0x00,0x00,0x00,  // S
0x00,0x00,0x00,0x00,0x1F,0xF8,0x1F,0xF8,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,  // T
0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1C,0x38,0x0F,0xF0,0x07,0xE0,0x00,0x00,0x00,0x00,  // U
0x00,0x00,0x00,0x00,0x30,0x18,0x18,0x30,0x18,0x30,0x18,0x30,0x0C,0x60,0x0C,0x60,0x0E,0xE0,0x06,0xC0,0x06,0xC0,0x03,0x80,0x03,0x80,0x03,0x80,0x00,0x00,0x00,0x00,  // V
0x00,0x00,0x00,0x00,0x31,0xC6,0x31,0xC6,0x31,0xC6,0x1B,0x6C,0x1B,0x6C,0x1B,0x6C,0x1B,0x6C,0x1B,0x6C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x00,0x00,0x00,0x00,  // W
0x00,0x00,0x00,0x00,0x18,0x30,0x1C,0x70,0x0C,0x60,0x06,0xC0,0x07,0xC0,0x03,0x80,0x03,0x80,0x07,0xC0,0x06,0xC0,0x0C,0x60,0x1C,0x70,0x18,0x30,0x00,0x00,0x00,0x00,  // X
0x00,0x00,0x00,0x00,0x18,0x18,0x1C,0x38,0x0C,0x30,0x06,0x60,0x06,0x60,0x03,0xC0,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,  // Y
0x00,0x00,0x00,0x00,0x07,0xF8,0x07,0xF8,0x00,0x30,0x00,0x60,0x00,0xE0,0x00,0xC0,0x01,0x80,0x03,0x80,0x03,0x00,0x06,0x00,0x0F,0xF8,0x0F,0xF8,0x00,0x00,0x00,0x00,  // Z
0x00,0x00,0x03,0xC0,0x03,0xC0,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0xC0,0x03,0xC0,0x00,0x00,  // [
0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,  // <backslash>
0x00,0x00,0x03,0xC0,0x03,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x03,0xC0,0x03,0xC0,0x00,0x00,  // ]
0x00,0x00,0x01,0x80,0x03,0xC0,0x03,0xC0,0x06,0x60,0x06,0x60,0x06,0x60,0x0C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,  // _

0x00,0x00,0x00,0x00,0x01,0x80,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // `
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,0x0F,0xE0,0x0C,0x60,0x01,0xE0,0x07,0xE0,0x0E,0x60,0x0C,0x60,0x0F,0xE0,0x07,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,  // a
0x00,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0D,0xC0,0x0F,0xE0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x0F,0xE0,0x0D,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // b
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x60,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0E,0x60,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // c
0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x03,0xB0,0x07,0xF0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x07,0xF0,0x03,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,  // d
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x07,0xC0,0x0C,0x60,0x0F,0xE0,0x0F,0xE0,0x0C,0x00,0x0E,0x60,0x07,0xC0,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,  // e
0x00,0x00,0x03,0xC0,0x07,0xC0,0x06,0x00,0x0F,0x80,0x0F,0x80,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // f
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x60,0x0F,0xE0,0x1C,0xE0,0x18,0x60,0x18,0x60,0x18,0x60,0x1C,0xE0,0x0F,0xE0,0x07,0x60,0x18,0x60,0x1F,0xE0,0x0F,0xC0,0x00,0x00,  // g
0x00,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0D,0xE0,0x0F,0xF0,0x0E,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,  // h
0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,  // i
0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x07,0x80,0x07,0x00,  // j
0x00,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x60,0x0C,0xC0,0x0D,0x80,0x0F,0x80,0x0F,0xC0,0x0E,0xC0,0x0C,0xC0,0x0C,0x60,0x0C,0x60,0x00,0x00,0x00,0x00,0x00,0x00,  // k
0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,  // l
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x38,0x3F,0xFC,0x39,0xCC,0x31,0x8C,0x31,0x8C,0x31,0x8C,0x31,0x8C,0x31,0x8C,0x31,0x8C,0x00,0x00,0x00,0x00,0x00,0x00,  // m
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xE0,0x0F,0xF0,0x0E,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,  // n
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x07,0xE0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x07,0xE0,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // o

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0xC0,0x0F,0xE0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x0F,0xE0,0x0D,0xC0,0x0C,0x00,0x0C,0x00,0x0C,0x00,  // p
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xB0,0x07,0xF0,0x0E,0x70,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0E,0x70,0x07,0xF0,0x03,0xB0,0x00,0x30,0x00,0x30,0x00,0x30,  // q
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x70,0x03,0xF0,0x03,0x80,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // r
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,0x0F,0xE0,0x0C,0x60,0x0F,0x00,0x07,0xC0,0x00,0xE0,0x0C,0x60,0x0F,0xE0,0x07,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // s
0x00,0x00,0x01,0x00,0x03,0x00,0x03,0x00,0x07,0xC0,0x07,0xC0,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0xC0,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // t
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x30,0x0C,0x70,0x0F,0xF0,0x07,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,  // u
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x06,0x30,0x06,0x30,0x03,0x60,0x03,0x60,0x03,0x60,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,  // v
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0xC6,0x31,0xC6,0x19,0xCC,0x1B,0x6C,0x1B,0x6C,0x1B,0x6C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x00,0x00,0x00,0x00,0x00,0x00,  // w
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x07,0x70,0x03,0x60,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x03,0x60,0x07,0x70,0x06,0x30,0x00,0x00,0x00,0x00,0x00,0x00,  // x
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x18,0x0C,0x18,0x06,0x30,0x06,0x30,0x03,0x60,0x03,0x60,0x03,0xE0,0x01,0xC0,0x01,0xC0,0x01,0x80,0x07,0x80,0x07,0x00,  // y
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x03,0xF8,0x00,0x30,0x00,0x70,0x00,0xE0,0x01,0xC0,0x01,0x80,0x03,0xF8,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,  // z
0x01,0xC0,0x03,0xC0,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x0E,0x00,0x0E,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0xC0,0x01,0xC0,0x00,0x00,  // {
0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,  // |
0x03,0x80,0x03,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x70,0x00,0x70,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x03,0xC0,0x03,0x80,0x00,0x00,  // }
0x00,0x00,0x00,0x00,0x07,0x88,0x0F,0xF8,0x08,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // ~
};



// 0x3E, 0x41, 0x41, 0x41, 0x22,  - that's a C starting at the back 1st pixel is top
// --xxxx--
// -x-----x
// -x-----x
// -x-----x
// --x---x-
//
// need to grab and 8 by 8 version of this.
//
static const uint8_t IRA font[] = {
0x00, 0x00, 0x00, 0x00, 0x00,
0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
0x18, 0x3C, 0x7E, 0x3C, 0x18,
0x1C, 0x57, 0x7D, 0x57, 0x1C,
0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
0x00, 0x18, 0x3C, 0x18, 0x00,
0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
0x00, 0x18, 0x24, 0x18, 0x00,
0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
0x30, 0x48, 0x3A, 0x06, 0x0E,
0x26, 0x29, 0x79, 0x29, 0x26,
0x40, 0x7F, 0x05, 0x05, 0x07,
0x40, 0x7F, 0x05, 0x25, 0x3F,
0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
0x7F, 0x3E, 0x1C, 0x1C, 0x08,
0x08, 0x1C, 0x1C, 0x3E, 0x7F,
0x14, 0x22, 0x7F, 0x22, 0x14,
0x5F, 0x5F, 0x00, 0x5F, 0x5F,
0x06, 0x09, 0x7F, 0x01, 0x7F,
0x00, 0x66, 0x89, 0x95, 0x6A,
0x60, 0x60, 0x60, 0x60, 0x60,
0x94, 0xA2, 0xFF, 0xA2, 0x94,
0x08, 0x04, 0x7E, 0x04, 0x08,
0x10, 0x20, 0x7E, 0x20, 0x10,
0x08, 0x08, 0x2A, 0x1C, 0x08,
0x08, 0x1C, 0x2A, 0x08, 0x08,
0x1E, 0x10, 0x10, 0x10, 0x10,
0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
0x30, 0x38, 0x3E, 0x38, 0x30,
0x06, 0x0E, 0x3E, 0x0E, 0x06,
0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x5F, 0x00, 0x00,
0x00, 0x07, 0x00, 0x07, 0x00,
0x14, 0x7F, 0x14, 0x7F, 0x14,
0x24, 0x2A, 0x7F, 0x2A, 0x12,
0x23, 0x13, 0x08, 0x64, 0x62,
0x36, 0x49, 0x56, 0x20, 0x50,
0x00, 0x08, 0x07, 0x03, 0x00,
0x00, 0x1C, 0x22, 0x41, 0x00,
0x00, 0x41, 0x22, 0x1C, 0x00,
0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
0x08, 0x08, 0x3E, 0x08, 0x08,
0x00, 0x80, 0x70, 0x30, 0x00,
0x08, 0x08, 0x08, 0x08, 0x08,
0x00, 0x00, 0x60, 0x60, 0x00,
0x20, 0x10, 0x08, 0x04, 0x02,
0x3E, 0x51, 0x49, 0x45, 0x3E,
0x00, 0x42, 0x7F, 0x40, 0x00,
0x72, 0x49, 0x49, 0x49, 0x46,
0x21, 0x41, 0x49, 0x4D, 0x33,
0x18, 0x14, 0x12, 0x7F, 0x10,
0x27, 0x45, 0x45, 0x45, 0x39,
0x3C, 0x4A, 0x49, 0x49, 0x31,
0x41, 0x21, 0x11, 0x09, 0x07,
0x36, 0x49, 0x49, 0x49, 0x36,
0x46, 0x49, 0x49, 0x29, 0x1E,
0x00, 0x00, 0x14, 0x00, 0x00,
0x00, 0x40, 0x34, 0x00, 0x00,
0x00, 0x08, 0x14, 0x22, 0x41,
0x14, 0x14, 0x14, 0x14, 0x14,
0x00, 0x41, 0x22, 0x14, 0x08,
0x02, 0x01, 0x59, 0x09, 0x06,
0x3E, 0x41, 0x5D, 0x59, 0x4E,
0x7C, 0x12, 0x11, 0x12, 0x7C,
0x7F, 0x49, 0x49, 0x49, 0x36,
0x3E, 0x41, 0x41, 0x41, 0x22, // C backwards 1st byte is start of c
0x7F, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x49, 0x49, 0x49, 0x41, // E backwards
0x7F, 0x09, 0x09, 0x09, 0x01,
0x3E, 0x41, 0x41, 0x51, 0x73,
0x7F, 0x08, 0x08, 0x08, 0x7F,
0x00, 0x41, 0x7F, 0x41, 0x00,
0x20, 0x40, 0x41, 0x3F, 0x01,
0x7F, 0x08, 0x14, 0x22, 0x41,
0x7F, 0x40, 0x40, 0x40, 0x40,
0x7F, 0x02, 0x1C, 0x02, 0x7F,
0x7F, 0x04, 0x08, 0x10, 0x7F,
0x3E, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x09, 0x09, 0x09, 0x06,
0x3E, 0x41, 0x51, 0x21, 0x5E,
0x7F, 0x09, 0x19, 0x29, 0x46,
0x26, 0x49, 0x49, 0x49, 0x32,
0x03, 0x01, 0x7F, 0x01, 0x03,
0x3F, 0x40, 0x40, 0x40, 0x3F,
0x1F, 0x20, 0x40, 0x20, 0x1F,
0x3F, 0x40, 0x38, 0x40, 0x3F,
0x63, 0x14, 0x08, 0x14, 0x63,
0x03, 0x04, 0x78, 0x04, 0x03,
0x61, 0x59, 0x49, 0x4D, 0x43,
0x00, 0x7F, 0x41, 0x41, 0x41,
0x02, 0x04, 0x08, 0x10, 0x20,
0x00, 0x41, 0x41, 0x41, 0x7F,
0x04, 0x02, 0x01, 0x02, 0x04,
0x40, 0x40, 0x40, 0x40, 0x40,
0x00, 0x03, 0x07, 0x08, 0x00,
0x20, 0x54, 0x54, 0x78, 0x40,
0x7F, 0x28, 0x44, 0x44, 0x38,
0x38, 0x44, 0x44, 0x44, 0x28,
0x38, 0x44, 0x44, 0x28, 0x7F,
0x38, 0x54, 0x54, 0x54, 0x18,
0x00, 0x08, 0x7E, 0x09, 0x02,
0x18, 0xA4, 0xA4, 0x9C, 0x78,
0x7F, 0x08, 0x04, 0x04, 0x78,
0x00, 0x44, 0x7D, 0x40, 0x00,
0x20, 0x40, 0x40, 0x3D, 0x00,
0x7F, 0x10, 0x28, 0x44, 0x00,
0x00, 0x41, 0x7F, 0x40, 0x00,
0x7C, 0x04, 0x78, 0x04, 0x78,
0x7C, 0x08, 0x04, 0x04, 0x78,
0x38, 0x44, 0x44, 0x44, 0x38,
0xFC, 0x18, 0x24, 0x24, 0x18,
0x18, 0x24, 0x24, 0x18, 0xFC,
0x7C, 0x08, 0x04, 0x04, 0x08,
0x48, 0x54, 0x54, 0x54, 0x24,
0x04, 0x04, 0x3F, 0x44, 0x24,
0x3C, 0x40, 0x40, 0x20, 0x7C,
0x1C, 0x20, 0x40, 0x20, 0x1C,
0x3C, 0x40, 0x30, 0x40, 0x3C,
0x44, 0x28, 0x10, 0x28, 0x44,
0x4C, 0x90, 0x90, 0x90, 0x7C,
0x44, 0x64, 0x54, 0x4C, 0x44,
0x00, 0x08, 0x36, 0x41, 0x00,
0x00, 0x00, 0x77, 0x00, 0x00,
0x00, 0x41, 0x36, 0x08, 0x00,
0x02, 0x01, 0x02, 0x04, 0x02,
0x3C, 0x26, 0x23, 0x26, 0x3C,
0x1E, 0xA1, 0xA1, 0x61, 0x12,
0x3A, 0x40, 0x40, 0x20, 0x7A,
0x38, 0x54, 0x54, 0x55, 0x59,
0x21, 0x55, 0x55, 0x79, 0x41,
0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
0x21, 0x55, 0x54, 0x78, 0x40,
0x20, 0x54, 0x55, 0x79, 0x40,
0x0C, 0x1E, 0x52, 0x72, 0x12,
0x39, 0x55, 0x55, 0x55, 0x59,
0x39, 0x54, 0x54, 0x54, 0x59,
0x39, 0x55, 0x54, 0x54, 0x58,
0x00, 0x00, 0x45, 0x7C, 0x41,
0x00, 0x02, 0x45, 0x7D, 0x42,
0x00, 0x01, 0x45, 0x7C, 0x40,
0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut
0xF0, 0x28, 0x25, 0x28, 0xF0,
0x7C, 0x54, 0x55, 0x45, 0x00,
0x20, 0x54, 0x54, 0x7C, 0x54,
0x7C, 0x0A, 0x09, 0x7F, 0x49,
0x32, 0x49, 0x49, 0x49, 0x32,
0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
0x32, 0x4A, 0x48, 0x48, 0x30,
0x3A, 0x41, 0x41, 0x21, 0x7A,
0x3A, 0x42, 0x40, 0x20, 0x78,
0x00, 0x9D, 0xA0, 0xA0, 0x7D,
0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
0x3D, 0x40, 0x40, 0x40, 0x3D,
0x3C, 0x24, 0xFF, 0x24, 0x24,
0x48, 0x7E, 0x49, 0x43, 0x66,
0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
0xFF, 0x09, 0x29, 0xF6, 0x20,
0xC0, 0x88, 0x7E, 0x09, 0x03,
0x20, 0x54, 0x54, 0x79, 0x41,
0x00, 0x00, 0x44, 0x7D, 0x41,
0x30, 0x48, 0x48, 0x4A, 0x32,
0x38, 0x40, 0x40, 0x22, 0x7A,
0x00, 0x7A, 0x0A, 0x0A, 0x72,
0x7D, 0x0D, 0x19, 0x31, 0x7D,
0x26, 0x29, 0x29, 0x2F, 0x28,
0x26, 0x29, 0x29, 0x29, 0x26,
0x30, 0x48, 0x4D, 0x40, 0x20,
0x38, 0x08, 0x08, 0x08, 0x08,
0x08, 0x08, 0x08, 0x08, 0x38,
0x2F, 0x10, 0xC8, 0xAC, 0xBA,
0x2F, 0x10, 0x28, 0x34, 0xFA,
0x00, 0x00, 0x7B, 0x00, 0x00,
0x08, 0x14, 0x2A, 0x14, 0x22,
0x22, 0x14, 0x2A, 0x14, 0x08,
0xAA, 0x00, 0x55, 0x00, 0xAA,
0xAA, 0x55, 0xAA, 0x55, 0xAA,
0x00, 0x00, 0x00, 0xFF, 0x00,
0x10, 0x10, 0x10, 0xFF, 0x00,
0x14, 0x14, 0x14, 0xFF, 0x00,
0x10, 0x10, 0xFF, 0x00, 0xFF,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x14, 0x14, 0x14, 0xFC, 0x00,
0x14, 0x14, 0xF7, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x14, 0x14, 0xF4, 0x04, 0xFC,
0x14, 0x14, 0x17, 0x10, 0x1F,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0x1F, 0x00,
0x10, 0x10, 0x10, 0xF0, 0x00,
0x00, 0x00, 0x00, 0x1F, 0x10,
0x10, 0x10, 0x10, 0x1F, 0x10,
0x10, 0x10, 0x10, 0xF0, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x10,
0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x10, 0x10, 0xFF, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x14,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x00, 0x00, 0x1F, 0x10, 0x17,
0x00, 0x00, 0xFC, 0x04, 0xF4,
0x14, 0x14, 0x17, 0x10, 0x17,
0x14, 0x14, 0xF4, 0x04, 0xF4,
0x00, 0x00, 0xFF, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x14, 0x14,
0x14, 0x14, 0xF7, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x17, 0x14,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0xF4, 0x14,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x00, 0x00, 0x1F, 0x10, 0x1F,
0x00, 0x00, 0x00, 0x1F, 0x14,
0x00, 0x00, 0x00, 0xFC, 0x14,
0x00, 0x00, 0xF0, 0x10, 0xF0,
0x10, 0x10, 0xFF, 0x10, 0xFF,
0x14, 0x14, 0x14, 0xFF, 0x14,
0x10, 0x10, 0x10, 0x1F, 0x00,
0x00, 0x00, 0x00, 0xF0, 0x10,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xFF, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFF, 0xFF,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x38, 0x44, 0x44, 0x38, 0x44,
0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
0x7E, 0x02, 0x02, 0x06, 0x06,
0x02, 0x7E, 0x02, 0x7E, 0x02,
0x63, 0x55, 0x49, 0x41, 0x63,
0x38, 0x44, 0x44, 0x3C, 0x04,
0x40, 0x7E, 0x20, 0x1E, 0x20,
0x06, 0x02, 0x7E, 0x02, 0x02,
0x99, 0xA5, 0xE7, 0xA5, 0x99,
0x1C, 0x2A, 0x49, 0x2A, 0x1C,
0x4C, 0x72, 0x01, 0x72, 0x4C,
0x30, 0x4A, 0x4D, 0x4D, 0x30,
0x30, 0x48, 0x78, 0x48, 0x30,
0xBC, 0x62, 0x5A, 0x46, 0x3D,
0x3E, 0x49, 0x49, 0x49, 0x00,
0x7E, 0x01, 0x01, 0x01, 0x7E,
0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
0x44, 0x44, 0x5F, 0x44, 0x44,
0x40, 0x51, 0x4A, 0x44, 0x40,
0x40, 0x44, 0x4A, 0x51, 0x40,
0x00, 0x00, 0xFF, 0x01, 0x03,
0xE0, 0x80, 0xFF, 0x00, 0x00,
0x08, 0x08, 0x6B, 0x6B, 0x08,
0x36, 0x12, 0x36, 0x24, 0x36,
0x06, 0x0F, 0x09, 0x0F, 0x06,
0x00, 0x00, 0x18, 0x18, 0x00,
0x00, 0x00, 0x10, 0x10, 0x00,
0x30, 0x40, 0xFF, 0x01, 0x01,
0x00, 0x1F, 0x01, 0x01, 0x1E,
0x00, 0x19, 0x1D, 0x17, 0x12,
0x00, 0x3C, 0x3C, 0x3C, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x00
};


#define CS_HI
#define CS_LO
#define RST_HI
#define RST_LO
#define DC_HI easygpio_outputSet(16,1);
#define DC_LO easygpio_outputSet(16,0);

#define ILI9340_TFTWIDTH  240
#define ILI9340_TFTHEIGHT 320

#define ILI9340_NOP     0x00
#define ILI9340_SWRESET 0x01
#define ILI9340_RDDID   0x04
#define ILI9340_RDDST   0x09

#define ILI9340_SLPIN   0x10
#define ILI9340_SLPOUT  0x11
#define ILI9340_PTLON   0x12
#define ILI9340_NORON   0x13

#define ILI9340_RDMODE  0x0A
#define ILI9340_RDMADCTL  0x0B
#define ILI9340_RDPIXFMT  0x0C
#define ILI9340_RDIMGFMT  0x0A
#define ILI9340_RDSELFDIAG  0x0F

#define ILI9340_INVOFF  0x20
#define ILI9340_INVON   0x21
#define ILI9340_GAMMASET 0x26
#define ILI9340_DISPOFF 0x28
#define ILI9340_DISPON  0x29

#define ILI9340_CASET   0x2A
#define ILI9340_PASET   0x2B
#define ILI9340_RAMWR   0x2C
#define ILI9340_RAMRD   0x2E

#define ILI9340_PTLAR   0x30
#define ILI9340_MADCTL  0x36


#define ILI9340_MADCTL_MY  0x80
#define ILI9340_MADCTL_MX  0x40
#define ILI9340_MADCTL_MV  0x20
#define ILI9340_MADCTL_ML  0x10
#define ILI9340_MADCTL_RGB 0x00
#define ILI9340_MADCTL_BGR 0x08
#define ILI9340_MADCTL_MH  0x04

#define ILI9340_PIXFMT  0x3A

#define ILI9340_FRMCTR1 0xB1
#define ILI9340_FRMCTR2 0xB2
#define ILI9340_FRMCTR3 0xB3
#define ILI9340_INVCTR  0xB4
#define ILI9340_DFUNCTR 0xB6

#define ILI9340_PWCTR1  0xC0
#define ILI9340_PWCTR2  0xC1
#define ILI9340_PWCTR3  0xC2
#define ILI9340_PWCTR4  0xC3
#define ILI9340_PWCTR5  0xC4
#define ILI9340_VMCTR1  0xC5
#define ILI9340_VMCTR2  0xC7

#define ILI9340_RDID1   0xDA
#define ILI9340_RDID2   0xDB
#define ILI9340_RDID3   0xDC
#define ILI9340_RDID4   0xDD

#define ILI9340_GMCTRP1 0xE0
#define ILI9340_GMCTRN1 0xE1
// Color definitions
#define	ILI9340_BLACK   0x0000
#define	ILI9340_BLUE    0x001F
#define	ILI9340_RED     0xF800
#define	ILI9340_GREEN   0x07E0
#define ILI9340_CYAN    0x07FF
#define ILI9340_MAGENTA 0xF81F
#define ILI9340_YELLOW  0xFFE0
#define ILI9340_WHITE   0xFFFF

#define PURPLE_ON_BLACK "\e[35;40m"
#define GREEN_ON_BLACK "\e[32;40m"


typedef struct  {
	uint16_t screen_width, screen_height;
	int16_t  cursor_x, cursor_y;
	int8_t   char_width, char_height;
	uint16_t back_color, front_color;
	uint16_t scroll_start;
} ILITERM, *ILITERMPTR;

ILITERM term;

//ILITERMPTR t = &term; // t is not used

void IFA  _wr_command(uint8_t c) {
    DC_LO;
    spi_tx8(1, c);
}

void IFA _wr_command16(uint16_t c) {
    DC_LO;
    spi_tx16(1, c);
}

void IFA _wr_data(uint8_t c) {
    DC_HI;
    spi_tx8(1, c);
}

void IFA _wr_data16(uint16_t c){
    DC_HI;
    spi_tx16(1, c);
}

void _delay_ms(uint32_t dl)
{
    os_delay_us(dl*1000);
}

void IFA ili9340_init(void) {

    _delay_ms(100);

    _wr_command(0xEF);
    _wr_data(0x03);
    _wr_data(0x80);
    _wr_data(0x02);

    _wr_command(0xCF);
    _wr_data(0x00);
    _wr_data(0XC1);
    _wr_data(0X30);

    _wr_command(0xED);
    _wr_data(0x64);
    _wr_data(0x03);
    _wr_data(0X12);
    _wr_data(0X81);

    _wr_command(0xE8);
    _wr_data(0x85);
    _wr_data(0x00);
    _wr_data(0x78);

    _wr_command(0xCB);
    _wr_data(0x39);
    _wr_data(0x2C);
    _wr_data(0x00);
    _wr_data(0x34);
    _wr_data(0x02);

    _wr_command(0xF7);
    _wr_data(0x20);

    _wr_command(0xEA);
    _wr_data(0x00);
    _wr_data(0x00);

    _wr_command(ILI9340_PWCTR1);    //Power control
    _wr_data(0x23);   //VRH[5:0]

    _wr_command(ILI9340_PWCTR2);    //Power control
    _wr_data(0x10);   //SAP[2:0];BT[3:0]

    _wr_command(ILI9340_VMCTR1);    //VCM control
    _wr_data(0x3e); //
    _wr_data(0x28);

    _wr_command(ILI9340_VMCTR2);    //VCM control2
    _wr_data(0x86);  //--

    _wr_command(ILI9340_MADCTL);    // Memory Access Control
    _wr_data(ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);

    _wr_command(ILI9340_PIXFMT);
    _wr_data(0x55);

    _wr_command(ILI9340_FRMCTR1);
    _wr_data(0x00);
    _wr_data(0x18);

    _wr_command(ILI9340_DFUNCTR);    // Display Function Control
    _wr_data(0x08);
    _wr_data(0x82);
    _wr_data(0x27);

    _wr_command(0xF2);    // 3Gamma Function Disable
    _wr_data(0x00);

    _wr_command(ILI9340_GAMMASET);    //Gamma curve selected
    _wr_data(0x01);

    _wr_command(ILI9340_GMCTRP1);    //Set Gamma
    _wr_data(0x0F);
    _wr_data(0x31);
    _wr_data(0x2B);
    _wr_data(0x0C);
    _wr_data(0x0E);
    _wr_data(0x08);
    _wr_data(0x4E);
    _wr_data(0xF1);
    _wr_data(0x37);
    _wr_data(0x07);
    _wr_data(0x10);
    _wr_data(0x03);
    _wr_data(0x0E);
    _wr_data(0x09);
    _wr_data(0x00);

    _wr_command(ILI9340_GMCTRN1);    //Set Gamma
    _wr_data(0x00);
    _wr_data(0x0E);
    _wr_data(0x14);
    _wr_data(0x03);
    _wr_data(0x11);
    _wr_data(0x07);
    _wr_data(0x31);
    _wr_data(0xC1);
    _wr_data(0x48);
    _wr_data(0x08);
    _wr_data(0x0F);
    _wr_data(0x0C);
    _wr_data(0x31);
    _wr_data(0x36);
    _wr_data(0x0F);

    _wr_command(ILI9340_SLPOUT);    //Exit Sleep
    _delay_ms(120);
    _wr_command(ILI9340_DISPON);    //Display on

    term.screen_width = ILI9340_TFTWIDTH;
    term.screen_height = ILI9340_TFTHEIGHT;
    term.char_height = 8;
    term.char_width = 6;
    term.back_color = 0x0000;
    term.front_color = 0xffff;
    term.cursor_x = term.cursor_y = 0;
    term.scroll_start = 0;
}

void IFA ili9340_pushColor(uint16_t color) {
    _wr_data16(color);
}

uint16_t IFA ili9340_width(void){
    return term.screen_width;
}

uint16_t IFA ili9340_height(void){
    return term.screen_height;
}


void IFA ili9340_setScrollStart(uint16_t start){
    _wr_command(0x37); // Vertical Scroll definition.
    _wr_data16(start);
    term.scroll_start = start;
}

void IFA ili9340_setScrollMargins(uint16_t top, uint16_t bottom) {
    // Did not pass in VSA as TFA+VSA=BFA must equal 320
    _wr_command(0x33); // Vertical Scroll definition.
    _wr_data16(top);
    _wr_data16(ili9340_height()-(top+bottom));
    _wr_data16(bottom);
}

void IFA ili9340_setAddrWindow(int16_t x0, int16_t y0, int16_t x1, int16_t y1) {
    _wr_command(ILI9340_CASET); // Column addr set
    _wr_data(x0 >> 8);
    _wr_data(x0 & 0xFF);     // XSTART
    _wr_data(x1 >> 8);
    _wr_data(x1 & 0xFF);     // XEND
    _wr_command(ILI9340_PASET); // Row addr set
    _wr_data(y0>>8);
    _wr_data(y0);     // YSTART
    _wr_data(y1>>8);
    _wr_data(y1);     // YEND
    _wr_command(ILI9340_RAMWR); // write to RAM
}


#define swap(a,b) {a^=b; b^=a; a^=b;}

void IFA ili9340_drawPixel(int16_t x, int16_t y, uint16_t color) {

    if((x < 0) ||(x >= term.screen_width) || (y < 0) || (y >= term.screen_height)) return;
    ili9340_setAddrWindow(x,y,x+1,y+1);
    _wr_data16(color);
}

// PS extracted this from Adafruit and added it in.
// Bresenham's algorithm - thx wikpedia
void IFA ili9340_drawLine(int16_t x0, int16_t y0,int16_t x1, int16_t y1,uint16_t color) {

    if (y0 == y1) {
	if (x1 > x0) {
	    ili9340_drawFastHLine(x0, y0, x1 - x0 + 1, color);
	} else if (x1 < x0) {
	    ili9340_drawFastHLine(x1, y0, x0 - x1 + 1, color);
	} else {
	    ili9340_drawPixel(x0, y0, color);
	}
	return;
    } else if (x0 == x1) {
	if (y1 > y0) {
	    ili9340_drawFastVLine(x0, y0, y1 - y0 + 1, color);
	} else {
	    ili9340_drawFastVLine(x0, y1, y0 - y1 + 1, color);
	}
	return;
    }

    uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep) {
	swap(x0, y0);
	swap(x1, y1);
    }
    if (x0 > x1) {
	swap(x0, x1);
	swap(y0, y1);
    }

    int16_t dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int16_t err = dx / 2;
    int16_t ystep;

    if (y0 < y1) {
	ystep = 1;
    } else {
	ystep = -1;
    }

    int16_t xbegin = x0;
    if (steep) {
	for (; x0<=x1; x0++) {
	    err -= dy;
	    if (err < 0) {
		int16_t len = x0 - xbegin;
		if (len) {
		    ili9340_drawFastVLine(y0, xbegin, len + 1, color);
		} else {
		    ili9340_drawPixel(y0, x0, color);
		}
		xbegin = x0 + 1;
		y0 += ystep;
		err += dx;
	    }
	}
	if (x0 > xbegin + 1) ili9340_drawFastVLine(y0, xbegin, x0 - xbegin, color);
    } else {
	for (; x0<=x1; x0++) {
	    err -= dy;
	    if (err < 0) {
		int16_t len = x0 - xbegin;
		if (len) {
		    ili9340_drawFastHLine(xbegin, y0, len + 1, color);
		} else {
		    ili9340_drawPixel(x0, y0, color);
		}
		xbegin = x0 + 1;
		y0 += ystep;
		err += dx;
	    }
	}
	if (x0 > xbegin + 1) ili9340_drawFastHLine(xbegin, y0, x0 - xbegin, color);
    }
}

// draw a rectangle - added in by PS.
void IFA ili9340_drawRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color,uint16_t backColor) {
    ili9340_fillRect(x+1,y+1,w-2,h-2,backColor);
    ili9340_drawFastVLine(x,y,h,color);
    ili9340_drawFastVLine(x+(w-1),y,h,color);
    ili9340_drawFastHLine(x+1,y,w-2,color);
    ili9340_drawFastHLine(x+1,y+(h-1),w-2,color);
}

// fill a rectangle
void IFA ili9340_fillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    //struct ili9340 *t = &term; // Not used

    //y = (y + term.scroll_start) % term.screen_height;

    // rudimentary clipping (drawChar w/big text requires this)
    //if((x >= t->screen_width) || (y >= t->screen_height)) return;
    if((x + w - 1) >= term.screen_width)  w = term.screen_width  - x;
    if((y + h - 1) >= term.screen_height) h = term.screen_height - y;

    ili9340_setAddrWindow(x, y, x+w-1, y+h-1);

    //uint8_t hi = color >> 8, lo = color;

    for(y=h; y>0; y--) {
	for(x=w; x>0; x--) {
	    _wr_data16(color);
	    //  _spi_write(hi);
	    // _spi_write(lo);
	}
    }
}


void IFA ili9340_setBackColor(uint16_t col){
    //uint8_t r, uint8_t g, uint8_t b
    term.back_color = col;
    //t->back_color = (uint16_t)r << 8 | (uint16_t)g << 4 | b;
}

void IFA ili9340_setFrontColor(uint16_t col){
    //struct ili9340 *t = &term;
    term.front_color = col;
    //t->front_color = (uint16_t)r << 8 | (uint16_t)g << 4 | b;
}

void IFA ili9340_drawChar(uint16_t x, uint16_t y, uint8_t ch){
    ili9340_setAddrWindow(x, y, x+term.char_width-1, y + term.char_height);

    // character glyph buffer
    uint8 _buf[5];
    uint8_t *ch32;
    int j,b;

    ch32 = (uint8_t *) (font+(ch*5));

    for(j = 0; j < 5; j++){
	_buf[j] = read_rom_uint8(ch32++);
    }

    for (b = 0; b < 8; b++){
	// draw 5 pixels for each column of the glyph
	for (j = 0; j < 5; j++){
 	    _wr_data16((_buf[j] & _BV(b))? term.front_color : term.back_color );
	}
	// draw one more separator pixel
	_wr_data16(term.back_color);
    }
}

void IFA ili9340_drawBigChar(uint16_t x, uint16_t y, uint8_t ch){
    uint16_t *ch32;
    uint16_t j,xx,yy;
    // character glyph buffer
    uint16_t _buf[16];

    ch32 = (uint16_t *) (arial_bold+((ch-32)*32));

    for(j = 0; j < 16; j++){
	_buf[j] = read_rom_uint16(ch32++); ch32++;
    }
    for (yy = 0; yy < 16; yy++){
	for (xx = 0; xx<16 ; xx++)
	    {
 	    	if (_buf[yy] & _BV(15-xx)) ili9340_drawPixel(x+xx,y+yy,term.front_color); else ili9340_drawPixel(x+xx,y+yy,term.back_color);
	    }
    }
}



void IFA ili9340_drawBigString(uint16_t x, uint16_t y, const char *text){
    //static char _buffer[128]; // buffer for 1 char
    //int len = strlen(text);
    const char *_ch;
    for(_ch = text; *_ch; _ch++){
	if(!*_ch) break;
	ili9340_drawBigChar(x, y, *_ch);
	x += 16;
    }

}


void IFA ili9340_drawString(uint16_t x, uint16_t y, const char *text){
    //static char _buffer[128]; // buffer for 1 char
    //int len = strlen(text);
    const char * _ch;

    for(_ch = text; *_ch; _ch++){
	if(!*_ch) break;
	ili9340_drawChar(x, y, *_ch);
	x += term.char_width;
    }

}


void IFA ili9340_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    //struct ili9340 *t = &term;
    if((x >= term.screen_width) || (y >= term.screen_height)) return;
    if((y+h-1) >= term.screen_height)
	h = term.screen_height-y;
    ili9340_setAddrWindow(x, y, x, y+h-1);
    //uint8_t hi = color >> 8, lo = color;
    while (h--) {
	_wr_data16(color);
	//_spi_write(hi);
	//_spi_write(lo);
	spi_tx16(1, color);
    }
}


void IFA ili9340_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
    //struct ili9340 *t = &term;
    if((x >= term.screen_width) || (y >= term.screen_height)) return;
    if((x+w-1) >= term.screen_width)  w = term.screen_width-x;
    ili9340_setAddrWindow(x, y, x+w-1, y);
    // uint8_t hi = color >> 8, lo = color;
    while (w--) {
	//_spi_write(hi);
	// _spi_write(lo);
	_wr_data16(color);
    }

}

void IFA ili9340_setRotation(uint8_t m) {
    //struct ili9340 *t = &term;
    _wr_command(ILI9340_MADCTL);
    int rotation = m % 4; // can't be higher than 3
    switch (rotation) {
	case 0:
	    _wr_data(ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);
	    term.screen_width  = ILI9340_TFTWIDTH;
	    term.screen_height = ILI9340_TFTHEIGHT;
	    break;
	case 1:
	    _wr_data(ILI9340_MADCTL_MV | ILI9340_MADCTL_BGR);
	    term.screen_width  = ILI9340_TFTHEIGHT;
	    term.screen_height = ILI9340_TFTWIDTH;
	    break;
	case 2:
	    _wr_data(ILI9340_MADCTL_MY | ILI9340_MADCTL_BGR);
	    term.screen_width  = ILI9340_TFTWIDTH;
	    term.screen_height = ILI9340_TFTHEIGHT;
	    break;
	case 3:
	    _wr_data(ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);
	    term.screen_width  = ILI9340_TFTHEIGHT;
	    term.screen_height = ILI9340_TFTWIDTH;
	    break;
    }
}

// ************************ graphic primitives done

#define VT100_SCREEN_WIDTH ili9340_width()
#define VT100_SCREEN_HEIGHT ili9340_height()
#define VT100_CHAR_WIDTH 6
#define VT100_CHAR_HEIGHT 8
#define VT100_HEIGHT (VT100_SCREEN_HEIGHT / VT100_CHAR_HEIGHT)
#define VT100_WIDTH (VT100_SCREEN_WIDTH / VT100_CHAR_WIDTH)

void vt100_init(void (*send_response)(char *str));
void vt100_putc(uint8_t ch);
void vt100_puts(const char *str);


char new_br[8];

#define KEY_ESC 0x1b
#define KEY_DEL 0x7f
#define KEY_BELL 0x07

#define STATE(NAME, EV, ARG) void IFA NAME( uint8_t EV, uint16_t ARG)

// states
enum {
    STATE_IDLE,
    STATE_ESCAPE,
    STATE_COMMAND
};

// events that are passed into states
enum {
    EV_CHAR = 1,
};

#define MAX_COMMAND_ARGS 4
static struct vt100 {
    union flags {
	uint8_t val;
	struct {
	    // 0 = cursor remains on last column when it gets there
	    // 1 = lines wrap after last column to next line
	    uint8_t cursor_wrap : 1;
	    uint8_t scroll_mode : 1;
	    uint8_t origin_mode : 1;
	};
    } flags;

    //uint16_t screen_width, screen_height;
    // cursor position on the screen (0, 0) = top left corner.
    int16_t cursor_x, cursor_y;
    int16_t saved_cursor_x, saved_cursor_y; // used for cursor save restore
    int16_t scroll_start_row, scroll_end_row;
    // character width and height
    int8_t char_width, char_height;
    // colors used for rendering current characters
    uint16_t back_color, front_color;
    int16_t saved_back_color, saved_front_color; // used for cursor save restore 7 and 8 - added ps
    // the starting y-position of the screen scroll
    uint16_t scroll_value;
    // command arguments that get parsed as they appear in the terminal
    uint8_t narg; uint16_t args[MAX_COMMAND_ARGS];
    // current arg pointer (we use it for parsing)
    uint8_t carg;

    void (*state) (uint8_t ev, uint16_t arg);
    void (*send_response)(char *str);
    void (*ret_state)(uint8_t ev, uint16_t arg);
} term2;

STATE(_st_idle, ev, arg);
STATE(_st_esc_sq_bracket,  ev, arg);
STATE(_st_esc_question, ev, arg);
STATE(_st_esc_hash, ev, arg);

void IFA _vt100_reset(void){
    //term.screen_width = VT100_SCREEN_WIDTH;
    //term.screen_height = VT100_SCREEN_HEIGHT;
    term2.char_height = VT100_CHAR_HEIGHT;
    term2.char_width = VT100_CHAR_WIDTH;
    term2.back_color = 0x0000;
    term2.front_color = 0xffff;
    term2.cursor_x = term2.cursor_y = term2.saved_cursor_x = term2.saved_cursor_y = 0;
    term2.narg = 0;
    term2.state = _st_idle;
    term2.ret_state = 0;
    term2.scroll_value = 0;
    term2.scroll_start_row = 0;
    term2.scroll_end_row = VT100_HEIGHT; // outside of screen = whole screen scrollable
    term2.flags.cursor_wrap = 0;
    term2.flags.origin_mode = 0;
    ili9340_setFrontColor(term2.front_color);
    ili9340_setBackColor(term2.back_color);
    ili9340_setScrollMargins(0, 0);
    ili9340_setScrollStart(0);
}

void IFA _vt100_resetScroll(void){
    term2.scroll_start_row = 0;
    term2.scroll_end_row = VT100_HEIGHT;
    term2.scroll_value = 0;
    ili9340_setScrollMargins(0, 0);
    ili9340_setScrollStart(0);
}

#define VT100_CURSOR_X() (term2.cursor_x * term2.char_width)

uint16_t vt100_cursor_y(){
    // if within the top or bottom margin areas then normal addressing
    if(term2.cursor_y < term2.scroll_start_row || term2.cursor_y >= term2.scroll_end_row){
	return term2.cursor_y * VT100_CHAR_HEIGHT;
    } else {
	// otherwise we are inside scroll area
	uint16_t scroll_height = term2.scroll_end_row - term2.scroll_start_row;
	uint16_t row = term2.cursor_y + term2.scroll_value;
	if((term2.cursor_y + term2.scroll_value) >= term2.scroll_end_row) {
	    row -= scroll_height;
	}

	return row * VT100_CHAR_HEIGHT;
    }
}

/*
inline uint16_t VT100_CURSOR_Y(){
    // if within the top or bottom margin areas then normal addressing
    if(term2.cursor_y < term2.scroll_start_row || term2.cursor_y >= term2.scroll_end_row){
	return term2.cursor_y * VT100_CHAR_HEIGHT;
    } else {
	// otherwise we are inside scroll area
	uint16_t scroll_height = term2.scroll_end_row - term2.scroll_start_row;
	uint16_t row = term2.cursor_y + term2.scroll_value;

	if((term2.cursor_y + term2.scroll_value) >= term2.scroll_end_row) {
	    row -= scroll_height;
	}

	return row * VT100_CHAR_HEIGHT;
    }
}
*/

void IFA _vt100_clearLines(uint16_t start_line, uint16_t end_line){
    int c;
    for(c = start_line; c <= end_line; c++){
	uint16_t cy = term2.cursor_y;
	term2.cursor_y = c;
	//ili9340_fillRect(0, VT100_CURSOR_Y(), VT100_SCREEN_WIDTH, VT100_CHAR_HEIGHT, 0x0000);
	ili9340_fillRect(0, vt100_cursor_y(), VT100_SCREEN_WIDTH, VT100_CHAR_HEIGHT, 0x0000);
	term2.cursor_y = cy;
    }
}

// scrolls the scroll region up (lines > 0) or down (lines < 0)
void IFA _vt100_scroll(int16_t lines){
    if(!lines) return;

    // get height of scroll area in rows
    uint16_t scroll_height = term2.scroll_end_row - term2.scroll_start_row;
    // clearing of lines that we have scrolled up or down
    if(lines > 0){
	_vt100_clearLines(term2.scroll_start_row, term2.scroll_start_row+lines-1);
	// update the scroll value (wraps around scroll_height)
	term2.scroll_value = (term2.scroll_value + lines) % scroll_height;
    } else if(lines < 0){
	_vt100_clearLines(term2.scroll_end_row - lines, term2.scroll_end_row - 1);
	// make sure that the value wraps down
	term2.scroll_value = (scroll_height + term2.scroll_value + lines) % scroll_height;
    }
    uint16_t scroll_start = (term2.scroll_start_row + term2.scroll_value) * VT100_CHAR_HEIGHT;
    ili9340_setScrollStart(scroll_start);

}

// moves the cursor relative to current cursor position and scrolls the screen
void IFA _vt100_move(int16_t right_left, int16_t bottom_top){
    // calculate how many lines we need to move down or up if x movement goes outside screen
    int16_t new_x = right_left + term2.cursor_x;
    if(new_x > VT100_WIDTH){
	if(term2.flags.cursor_wrap){
	    bottom_top += new_x / VT100_WIDTH;
	    term2.cursor_x = new_x % VT100_WIDTH - 1;
	} else {
	    term2.cursor_x = VT100_WIDTH;
	}
    } else if(new_x < 0){
	bottom_top += new_x / VT100_WIDTH - 1;
	term2.cursor_x = VT100_WIDTH - (abs(new_x) % VT100_WIDTH) + 1;
    } else {
	term2.cursor_x = new_x;
    }

    if(bottom_top){
	int16_t new_y = term2.cursor_y + bottom_top;
	int16_t to_scroll = 0;
	if(new_y >= term2.scroll_end_row){
	    to_scroll = (new_y - term2.scroll_end_row) + 1;
	    // place cursor back within the scroll region
	    term2.cursor_y = term2.scroll_end_row - 1; //new_y - to_scroll;
	    //scroll = new_y - term2bottom_margin;
	    //term2cursor_y = term2bottom_margin;
	} else if(new_y < term2.scroll_start_row){
	    to_scroll = (new_y - term2.scroll_start_row);
	    term2.cursor_y = term2.scroll_start_row; //new_y - to_scroll;
	    //scroll = new_y / (term2bottom_margin - term2top_margin) - 1;
	    //term2cursor_y = term2top_margin;
	} else {
	    // otherwise we move as normal inside the screen
	    term2.cursor_y = new_y;
	}
	_vt100_scroll(to_scroll);
    }
}

void IFA _vt100_drawCursor(){
    //uint16_t x = t->cursor_x * t->char_width;
    //uint16_t y = t->cursor_y * t->char_height;

    //ili9340_fillRect(x, y, t->char_width, t->char_height, t->front_color);
}

// sends the character to the display and updates cursor position
void IFA _vt100_putc(uint8_t ch){
    if(ch < 0x20 || ch > 0x7e){
	static const char hex[] = "0123456789abcdef";
	_vt100_putc('0');
	_vt100_putc('x');
	_vt100_putc(hex[((ch & 0xf0) >> 4)]);
	_vt100_putc(hex[(ch & 0x0f)]);
	return;
    }

    // calculate current cursor position in the display ram
    uint16_t x = VT100_CURSOR_X();
    uint16_t y = vt100_cursor_y();

    ili9340_setFrontColor(term2.front_color);
    ili9340_setBackColor(term2.back_color);
    ili9340_drawChar(x, y, ch);

    // move cursor right
    _vt100_move(1, 0);
    _vt100_drawCursor();
}

void IFA vt100_puts(const char *str){
    while(*str){
	vt100_putc(*str++);
    }
}

STATE(_st_command_arg, ev, arg){
    switch(ev){
	case EV_CHAR: {
	    if(isdigit(arg)){ // a digit argument
		term2.args[term2.narg] = term2.args[term2.narg] * 10 + (arg - '0');
	    } else if(arg == ';') { // separator
		term2.narg++;
	    } else { // no more arguments
		// go back to command state
		term2.narg++;
		if(term2.ret_state){
		    term2.state = term2.ret_state;
		}
		else {
		    term2.state = _st_idle;
		}
		// execute next state as well because we have already consumed a char!
		term2.state(ev, arg);
	    }
	    break;
	}
    }
}

STATE(_st_esc_sq_bracket,ev, arg){
    switch(ev){
	case EV_CHAR: {
	    if(isdigit(arg)){ // start of an argument
		term2.ret_state = _st_esc_sq_bracket;
		_st_command_arg(ev, arg);
		term2.state = _st_command_arg;
	    } else if(arg == ';'){ // arg separator.
		// skip. And also stay in the command state
	    } else { // otherwise we execute the command and go back to idle
		switch(arg){
		    case 'A': {// move cursor up (cursor stops at top margin)
			int n = (term2.narg > 0)?term2.args[0]:1;
			term2.cursor_y -= n;
			if(term2.cursor_y < 0) term2.cursor_y = 0;
			term2.state = _st_idle;
			break;
		    }
		    case 'B': { // cursor down (cursor stops at bottom margin)
			int n = (term2.narg > 0)?term2.args[0]:1;
			term2.cursor_y += n;
			if(term2.cursor_y > VT100_HEIGHT) term2.cursor_y = VT100_HEIGHT;
			term2.state = _st_idle;
			break;
		    }
		    case 'C': { // cursor right (cursor stops at right margin)
			int n = (term2.narg > 0)?term2.args[0]:1;
			term2.cursor_x += n;
			if(term2.cursor_x > VT100_WIDTH) term2.cursor_x = VT100_WIDTH;
			term2.state = _st_idle;
			break;
		    }
		    case 'D': { // cursor left
			int n = (term2.narg > 0)?term2.args[0]:1;
			term2.cursor_x -= n;
			if(term2.cursor_x < 0) term2.cursor_x = 0;
			term2.state = _st_idle;
			break;
		    }
		    case 'f':
		    case 'H': { // move cursor to position (default 0;0)
			// cursor stops at respective margins
			term2.cursor_x = (term2.narg >= 1)?(term2.args[1]-1):0;
			term2.cursor_y = (term2.narg == 2)?(term2.args[0]-1):0;
			if(term2.flags.origin_mode) {
			    term2.cursor_y += term2.scroll_start_row;
			    if(term2.cursor_y >= term2.scroll_end_row){
				term2.cursor_y = term2.scroll_end_row - 1;
			    }
			}
			if(term2.cursor_x > VT100_WIDTH) term2.cursor_x = VT100_WIDTH;
			if(term2.cursor_y > VT100_HEIGHT) term2.cursor_y = VT100_HEIGHT;
			term2.state = _st_idle;
			break;
		    }
		    case 'J':{// clear screen from cursor up or down
			//uint16_t y = VT100_CURSOR_Y();
			if(term2.narg == 0 || (term2.narg == 1 && term2.args[0] == 0)){
			    // clear down to the bottom of screen (including cursor)
			    _vt100_clearLines( term2.cursor_y, VT100_HEIGHT);
			} else if(term2.narg == 1 && term2.args[0] == 1){
			    // clear top of screen to current line (including cursor)
			    _vt100_clearLines( 0, term2.cursor_y);
			} else if(term2.narg == 1 && term2.args[0] == 2){
			    // clear whole screen
			    _vt100_clearLines( 0, VT100_HEIGHT);
			    // reset scroll value
			    _vt100_resetScroll();
			}
			term2.state = _st_idle;
			break;
		    }
		    case 'K':{// clear line from cursor right/left
			uint16_t x = VT100_CURSOR_X();
			//uint16_t y = VT100_CURSOR_Y();
			uint16_t y = vt100_cursor_y();

			if(term2.narg == 0 || (term2.narg == 1 && term2.args[0] == 0)){
			    // clear to end of line (to \n or to edge?)
			    // including cursor
			    ili9340_fillRect(x, y, VT100_SCREEN_WIDTH - x, VT100_CHAR_HEIGHT, term2.back_color);
			} else if(term2.narg == 1 && term2.args[0] == 1){
			    // clear from left to current cursor position
			    ili9340_fillRect(0, y, x + VT100_CHAR_WIDTH, VT100_CHAR_HEIGHT, term2.back_color);
			} else if(term2.narg == 1 && term2.args[0] == 2){
			    // clear whole current line
			    ili9340_fillRect(0, y, VT100_SCREEN_WIDTH, VT100_CHAR_HEIGHT, term2.back_color);
			}
			term2.state = _st_idle;
			break;
		    }

		    case 'L': // insert lines (args[0] = number of lines)
		    case 'M': // delete lines (args[0] = number of lines)
			term2.state = _st_idle;
			break;
		    case 'P': {// delete characters args[0] or 1 in front of cursor
			// TODO: this needs to correctly delete n chars
			int n = ((term2.narg > 0)?term2.args[0]:1);
			_vt100_move( -n, 0);
			int c;
			for(c = 0; c < n; c++){
			    _vt100_putc(' ');
			}
			term2.state = _st_idle;
			break;
		    }
		    case 'c':{ // query device code
			//term2.send_response("\e[?1;0c");
			term2.state = _st_idle;
			break;
		    }
		    case 'x': {
			term2.state = _st_idle;
			break;
		    }
		    case 's':{// save cursor pos
			term2.saved_cursor_x = term2.cursor_x;
			term2.saved_cursor_y = term2.cursor_y;
			term2.state = _st_idle;
			break;
		    }
		    case 'u':{// restore cursor pos
			term2.cursor_x = term2.saved_cursor_x;
			term2.cursor_y = term2.saved_cursor_y;
			//_vt100_moveCursor(term, term2saved_cursor_x, term2saved_cursor_y);
			term2.state = _st_idle;
			break;
		    }
		    case 'h':
		    case 'l': {
			term2.state = _st_idle;
			break;
		    }

		    case 'g': {
			term2.state = _st_idle;
			break;
		    }
		    case 'm': { // sets colors. Accepts up to 3 args
			// [m means reset the colors to default
			if(!term2.narg){
			    term2.front_color = 0xffff;
			    term2.back_color = 0x0000;
			}
			while(term2.narg){
			    term2.narg--;
			    int n = term2.args[term2.narg];
			    static const uint16_t colors[] = {
				0x0000, // black
				0xf800, // red
				0x0780, // green
				0xfe00, // yellow
				0x001f, // blue
				0xf81f, // magenta
				0x07ff, // cyan
				0xffff // white
			    };
			    if(n == 0){ // all attributes off
				term2.front_color = 0xffff;
				term2.back_color = 0x0000;

				ili9340_setFrontColor(term2.front_color);
				ili9340_setBackColor(term2.back_color);
			    }
			    if(n >= 30 && n < 38){ // fg colors
				term2.front_color = colors[n-30];
				ili9340_setFrontColor(term2.front_color);
			    } else if(n >= 40 && n < 48){
				term2.back_color = colors[n-40];
				ili9340_setBackColor(term2.back_color);
			    }
			}
			term2.state = _st_idle;
			break;
		    }

		    case '@': // Insert Characters
			term2.state = _st_idle;
			break;
		    case 'r': // Set scroll region (top and bottom margins)
			// the top value is first row of scroll region
			// the bottom value is the first row of static region after scroll
			if(term2.narg == 2 && term2.args[0] < term2.args[1]){
			    // [1;40r means scroll region between 8 and 312
			    // bottom margin is 320 - (40 - 1) * 8 = 8 pix
			    term2.scroll_start_row = term2.args[0] - 1;
			    term2.scroll_end_row = term2.args[1] - 1;
			    uint16_t top_margin = term2.scroll_start_row * VT100_CHAR_HEIGHT;
			    uint16_t bottom_margin = VT100_SCREEN_HEIGHT -
				(term2.scroll_end_row * VT100_CHAR_HEIGHT);
			    ili9340_setScrollMargins(top_margin, bottom_margin);
			    //ili9340_setScrollStart(0); // reset scroll
			} else {
			    _vt100_resetScroll();
			}
			term2.state = _st_idle;
			break;
		    case 'i': // Printing
		    case 'y': // self test modes..
		    case '=':{ // argument follows...
			//term2state = _st_screen_mode;
			term2.state = _st_idle;
			break;
		    }
		    case '?': // '[?' escape mode
			term2.state = _st_esc_question;
			break;

		    case 'q' :  vt100_puts("\r\n"); // on-screen LEDS added PS
			//char bfr[20];
			switch (term2.args[0])
			    { case 0 : ili9340_drawRect(186,6,10,10,ILI9340_RED,ILI9340_BLACK);
				    ili9340_drawRect(200,6,10,10,ILI9340_RED,ILI9340_BLACK);
				    ili9340_drawRect(214,6,10,10,ILI9340_RED,ILI9340_BLACK);
				    ili9340_drawRect(228,6,10,10,ILI9340_RED,ILI9340_BLACK);
				    break;
				case 1 : ili9340_fillRect(186,6,10,10,ILI9340_RED); break;
				case 2 : ili9340_fillRect(200,6,10,10,ILI9340_RED); break;
				case 3 : ili9340_fillRect(214,6,10,10,ILI9340_RED); break;
				case 4 : ili9340_fillRect(228,6,10,10,ILI9340_RED); break;

				case 5 : ili9340_drawRect(186,6,10,10,ILI9340_RED,ILI9340_BLACK); break;
				case 6 : ili9340_drawRect(200,6,10,10,ILI9340_RED,ILI9340_BLACK); break;
				case 7 : ili9340_drawRect(214,6,10,10,ILI9340_RED,ILI9340_BLACK); break;
				case 8 : ili9340_drawRect(228,6,10,10,ILI9340_RED,ILI9340_BLACK); break;
			    }
			term2.state = _st_idle;
			break;


		    default: { // unknown sequence

			term2.state = _st_idle;
			break;
		    }
		}
		//term2state = _st_idle;
	    } // else
	    break;
	}
	default: { // switch (ev)
	    // for all other events restore normal mode
	    term2.state = _st_idle;
	}
    }
}

STATE(_st_esc_question, ev, arg){
    // DEC mode commands
    switch(ev){
	case EV_CHAR: {
	    if(isdigit(arg)){ // start of an argument
		term2.ret_state = _st_esc_question;
		_st_command_arg( ev, arg);
		term2.state = _st_command_arg;
	    } else if(arg == ';'){ // arg separator.
		// skip. And also stay in the command state
	    } else {
		switch(arg) {
		    case 'l':
			// dec mode: OFF (arg[0] = function)
		    case 'h': {
			// dec mode: ON (arg[0] = function)
			switch(term2.args[0]){
			    case 1: { // cursor keys mode
				// h = esc 0 A for cursor up
				// l = cursor keys send ansi commands
				break;
			    }
			    case 2: { // ansi / vt52
				// h = ansi mode
				// l = vt52 mode
				break;
			    }
			    case 3: {
				// h = 132 chars per line
				// l = 80 chars per line
				break;
			    }
			    case 4: {
				// h = smooth scroll
				// l = jump scroll
				break;
			    }
			    case 5: {
				// h = black on white bg
				// l = white on black bg
				break;
			    }
			    case 6: {
				// h = cursor relative to scroll region
				// l = cursor independent of scroll region
				term2.flags.origin_mode = (arg == 'h')?1:0;
				break;
			    }
			    case 7: {
				// h = new line after last column
				// l = cursor stays at the end of line
				term2.flags.cursor_wrap = (arg == 'h')?1:0;
				break;
			    }
			    case 8: {
				// h = keys will auto repeat
				// l = keys do not auto repeat when held down
				break;
			    }
			    case 9: {
				// h = display interlaced
				// l = display not interlaced
				break;
			    }
				// 10-38 - all quite DEC speciffic commands so omitted here
			}
			term2.state = _st_idle;
			break;
		    }
		    case 'i': /* Printing */
		    case 'n': /* Request printer status */
		    default:
			term2.state = _st_idle;
			break;
		}
		term2.state = _st_idle;
	    }
	}
    }
}

STATE(_st_esc_left_br, ev, arg){
    switch(ev){
	case EV_CHAR: {
	    switch(arg) {
		case 'A':
		case 'B':
		    // translation map command?
		case '0':
		case 'O':
		    // another translation map command?
		    term2.state = _st_idle;
		    break;
		default:
		    term2.state = _st_idle;
	    }
	    //term2state = _st_idle;
	}
    }
}

STATE(_st_esc_right_br, ev, arg){
    switch(ev){
	case EV_CHAR: {
	    switch(arg) {
		case 'A':
		case 'B':
		    // translation map command?
		case '0':
		case 'O':
		    // another translation map command?
		    term2.state = _st_idle;
		    break;
		default:
		    term2.state = _st_idle;
	    }
	    //term2state = _st_idle;
	}
    }
}

STATE(_st_esc_hash, ev, arg){
    switch(ev){
	case EV_CHAR: {
	    switch(arg) {
		case '8': {
		    // self test: fill the screen with 'E'

		    term2.state = _st_idle;
		    break;
		}
		default:
		    term2.state = _st_idle;
	    }
	}
    }
}

STATE(_st_escape,ev, arg){
    int c;
    switch(ev){
	case EV_CHAR: {
#define CLEAR_ARGS					\
	    { term2.narg = 0;				\
		for (c = 0; c < MAX_COMMAND_ARGS; c++)	\
		    term2.args[c] = 0; }		\

	    switch(arg){
		case '[': { // command
		    // prepare command state and switch to it
		    CLEAR_ARGS;
		    term2.state = _st_esc_sq_bracket;
		    break;
		}
		case '(': /* ESC ( */
		    CLEAR_ARGS;
		    term2.state = _st_esc_left_br;
		    break;
		case ')': /* ESC ) */
		    CLEAR_ARGS;
		    term2.state = _st_esc_right_br;
		    break;
		case '#': // ESC #
		    CLEAR_ARGS;
		    term2.state = _st_esc_hash;
		    break;
		case 'P': //ESC P (DCS, Device Control String)
		    term2.state = _st_idle;
		    break;
		case 'D': // moves cursor down one line and scrolls if necessary
		    // move cursor down one line and scroll window if at bottom line
		    _vt100_move( 0, 1);
		    term2.state = _st_idle;
		    break;
		case 'M': // Cursor up
		    // move cursor up one line and scroll window if at top line
		    _vt100_move(0, -1);
		    term2.state = _st_idle;
		    break;
		case 'E': // next line
		    // same as '\r\n'
		    _vt100_move( 0, 1);
		    term2.cursor_x = 0;
		    term2.state = _st_idle;
		    break;
		case '7': // Save attributes and cursor position
		    term2.saved_cursor_x = term2.cursor_x;
		    term2.saved_cursor_y = term2.cursor_y;
		    term2.saved_back_color = term2.back_color;
		    term2.saved_front_color = term2.front_color;
		    term2.state = _st_idle;
		    break;
		case 's':
		    term2.saved_cursor_x = term2.cursor_x;
		    term2.saved_cursor_y = term2.cursor_y;
		    term2.state = _st_idle;
		    break;
		case '8': // Restore them
		    term2.cursor_x = term2.saved_cursor_x;
		    term2.cursor_y = term2.saved_cursor_y;
		    term2.back_color = term2.saved_back_color;
		    term2.front_color = term2.saved_front_color;
		    term2.state = _st_idle;
		    break;
		case 'u':
		    term2.cursor_x = term2.saved_cursor_x;
		    term2.cursor_y = term2.saved_cursor_y;
		    term2.state = _st_idle;
		    break;
		case '=': // Keypad into applications mode
		    term2.state = _st_idle;
		    break;
		case '>': // Keypad into numeric mode
		    term2.state = _st_idle;
		    break;
		case 'Z': // Report terminal type
		    // vt 100 response
		    //term2.send_response("\033[?1;0c");
		    // unknown terminal
		    //out("\033[?c");
		    term2.state = _st_idle;
		    break;
		case 'c': // Reset terminal to initial state
		    _vt100_reset();
		    term2.state = _st_idle;
		    break;
		case 'H': // Set tab in current position
		case 'N': // G2 character set for next character only
		case 'O': // G3 "               "
		case '<': // Exit vt52 mode
		    // ignore
		    term2.state = _st_idle;
		    break;
		case KEY_ESC: { // marks start of next escape sequence
		    // stay in escape state
		    break;
		}
		default: { // unknown sequence - return to normal mode
		    term2.state = _st_idle;
		    break;
		}
	    }
#undef CLEAR_ARGS
	    break;
	}
	default: {
	    // for all other events restore normal mode
	    term2.state = _st_idle;
	}
    }
}

STATE(_st_idle, ev, arg){
    switch(ev){
	case EV_CHAR: {
	    switch(arg){

		case 5: // AnswerBack for vt100's
		    //term2.send_response("X"); // should send SCCS_ID?
		    break;
		case '\n': { // new line
		    _vt100_move( 0, 1);
		    term2.cursor_x = 0;
		    //_vt100_moveCursor(term, 0, term2cursor_y + 1);
		    // do scrolling here!
		    break;
		}
		case '\r': { // carrage return (0x0d)
		    term2.cursor_x = 0;
		    //_vt100_move(term, 0, 1);
		    //_vt100_moveCursor(term, 0, term2cursor_y);
		    break;
		}
		case '\b': { // backspace 0x08
		    _vt100_move(-1, 0);
		    // backspace does not delete the character! Only moves cursor!
		    //ili9340_drawChar(term2cursor_x * term2char_width,
		    //	term2cursor_y * term2char_height, ' ');
		    break;
		}
		case KEY_DEL: { // del - delete character under cursor
		    // Problem: with current implementation, we can't move the rest of line
		    // to the left as is the proper behavior of the delete character
		    // fill the current position with background color
		    _vt100_putc(' ');
		    _vt100_move( -1, 0);
		    break;
		}
		case '\t': { // tab
		    // tab fills characters on the line until we reach a multiple of tab_stop
		    int tab_stop = 4;
		    int to_put = tab_stop - (term2.cursor_x % tab_stop);
		    while(to_put--) _vt100_putc( ' ');
		    break;
		}
		case KEY_BELL: { // bell is sent by bash for ex. when doing tab completion
		    // sound the speaker bell?
		    // skip
		    break;
		}
		case KEY_ESC: {// escape
		    term2.state = _st_escape;
		    break;
		}
		default: {
		    _vt100_putc( arg);
		    break;
		}
	    }
	    break;
	}
	default: {}
    }
}

// void IFA vt100_init(void (*send_response)(char *str)){
//term2.send_response = send_response;
// 	_vt100_reset();
// }

void IFA vt100_putc(uint8_t c){
    term2.state(EV_CHAR, 0x0000 | c);
}

uint16_t spiActive = 0;

void IFA iliStartup()
{
    sysCfg.enable13 = 1; // stop 13 use as an indicator
    spiActive = 1;
    easygpio_pinMode(16, EASYGPIO_NOPULL, EASYGPIO_OUTPUT);
    spi_init(1); // HSPI mode
    spi_clock(1,2,2); // will not work without this - too fast for display
    ili9340_init();
    ili9340_setRotation(0);
    _vt100_reset();
    // reset terminal and clear screen..
    vt100_puts("\e[c");   // terminal ok
    vt100_puts("\e[2J");  // erase entire screen
    vt100_puts("\e[?6l"); // absolute origin
    // print some fixed purple text top and bottom
    vt100_puts(PURPLE_ON_BLACK);
    vt100_puts("\e[2;1HSerial HC2016 Terminal 1.0");
    //vt100_puts("\e[39;1HBaud: 115200");
    // 4 LEDS in the top corner initially set to OFF
    ili9340_drawRect(186,6,10,10,ILI9340_RED,ILI9340_BLACK);
    ili9340_drawRect(200,6,10,10,ILI9340_RED,ILI9340_BLACK);
    ili9340_drawRect(214,6,10,10,ILI9340_RED,ILI9340_BLACK);
    ili9340_drawRect(228,6,10,10,ILI9340_RED,ILI9340_BLACK);
    // delimit fixed areas
    ili9340_drawFastHLine(0,20, 240, ILI9340_BLUE);
    ili9340_drawFastHLine(0,300, 240, ILI9340_RED);
    vt100_puts("\e[4;38r"); // set the scrolling region
    vt100_puts(GREEN_ON_BLACK);
    vt100_puts("\e[37;1H"); // Set up at line 37, char position 1
    vt100_puts("\e[0q"); // All top corner LEDs off
    spiActive=0;
}

// ************************ end of experimenting
